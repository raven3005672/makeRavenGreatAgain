var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x)
console.log(b.x)

// 结果
undefined
{n:2}

// 首先，a和b同时引用了{n:2}对象，接着执行到a.x = a = {n:2}语句
// 尽管赋值是从右到左的，但是[.]运算符的优先级比[=]要搞，所以这里先执行a.x，相当于为a(或者b)所指向的{n:1}对象新增了一个属性x，此时对象变为{n:1,x:undefined}。
// 之后按正常情况，从右到左进行赋值，a的引用变为{n:2}，b依然指向旧对象。
// 之后执行a.x = {n:2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也是旧对象，所以此时旧对象变为{n:1,x:{n:2}}
// 输出a.x的时候，重新解析a，此时a是指向新对象的{n:2}
// 输出b.x的时候，b为{n:1,x:{n:2}}


