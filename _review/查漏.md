# 查漏

## 原生具有iterator接口的数据结构

* Array
* Map
* Set
* String
* TypedArray
* arguments对象
* NodeList对象

## weakSet、weakMap

* weakSet只能是对象的集合，不能是任何类型的任意值。
* 集合中对象的引用为弱引用。如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着WeakSet中没有存储当前对象的列表，WeakSet是不可枚举的。
* weakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
* weakMap的键名指向的对象，不计入垃圾回收机制。（类似weakSet）

## 抽象类，new.target

只能被继承使用的类，就要用到new.target

返回使用new方法调用类时的类的名称，子类继承父类时，new.target会返回子类。

作用：限制类的调用方法，实现一个抽象类。

## 纯css固定宽高比

## await是怎么把promise结果返回的

await会暂停当前async function的执行，等待promise处理完成，若Promise正常处理（fulfilled），其回调的resolve函数参数作为await表达式的值，继续执行async function。

如果Promise处理异常（rejected），await表达式会把Promise的异常原因抛出。

如果await操作符后的表达式的值不是一个Promise，则返回该值本身。

## 长轮询/短轮询是什么？

短轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。

这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。

因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。

长轮询：当服务器收到客户端发来的请求后，服务端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则达到一定的时间限制（服务器端设置）才返回。客户端响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。

长轮询比短轮询，减少了很多不必要的http请求次数，节约了资源。缺点是挂起资源会导致浪费。

## cache-control属性，no-cache、no-store区别

## shouldComponentUpdate深比较/浅比较，什么是深比较/浅比较

浅比较也称引用相等，只检查左右两边是否是同一个对象的引用。

深比较也称原值相等，检查两个对象的所有属性是否都相等。

## websocket、心跳检查

为了证明客户端和服务器还活着。websocket在使用过程中，如果遭遇网络问题等突发情况，服务端没有触发onclose事件，这样会产生多余的链接，并且服务端会继续发送消息给客户端，造成数据丢失。因此需要一种机制来检测客户端和服务端是否处于正常连接的状态，心跳检测和重连机制就产生了。

思路：
1. 每隔一段事件，向服务其发送一个请求，服务器收到数据后再发送给客户端，正常情况下客户端通过onmessage事件是能监听到服务端返回的数据的，说明请求正常。
2. 如果在这个指定时间内，客户端没有收到服务端返回的响应消息，就判定链接断开了，使用websocket.close关闭连接。
3. 这个关闭连接的动作可以通过onclose事件监听到，因此在onclose事件内，我们可以调用reconnect事件进行重连操作。

## CSS实现宽高等比例变化

## margin-top: 20%是什么意思
