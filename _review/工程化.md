# 工程化相关

## CommonJS和ES6 Module的区别

### 动态与静态

最本质的区别在于CommonJS对模块依赖的解决是’动态的‘，而ES6Module是’静态的‘。

这里的‘动态’的含义是，模块依赖关系的建立发生在代码运行阶段；而’静态’的模块依赖关系是建立在代码编译阶段。

require模块路径可以动态指定，支持传入一个表达式，甚至可以通过if判断是否加载某个模块。CommonJS模块被执行前，没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段。

ES6Module的导入、导出语句都是申明是的，它不支持导入的路径是一个表达式，并且导入、导出语句必须位于模块的顶层作用域。ES6代码在便一阶段就可以分析出模块的依赖关系。

优点：

* 死代码检测和排除。
* 模块变量类型检测。
* 编译器优化。

### 值拷贝与动态映射

导入模块的时候，CommonJS获取的是一份导出值的拷贝；ES6模块是值的动态映射，并且是只读的。

```js
var count = 0;
module.exports = {
    count,
    add: function(a,b) {
        count +=1;
        return a+b;
    }
}

var count = require('./index').count;
var add = require('./index').add;
// count => 0
add();
// count => 0
count+=1;
// count => 1
```

```js
let count = 0;
let add = function(a,b) {
    count += 1;
    return a + b;
}
export { count, add }

import { count, add } from './index'
// count => 0
add();
// count => 1
count += 1
// error: count is read only
```

### 循环依赖

CommonJS是值拷贝的，循环依赖时拷贝的值为空对象，之后不会随着代码的执行发生改变。

ES6Module是动态映射的，可以更好的支持循环依赖。

## webpack配置入口出口

```js
module.exports = {
    // 入口文件的配置项
    entry: {},
    // 出口文件的配置项
    output: {},
    // 模块：例如解读CSS，图片如何转换，压缩
    module: {},
    // 插件：用于生产模板和各项功能
    plugins: [],
    // 配置webpack开发服务功能
    devServer: {}
}
```

### webpack3和webpack4的区别

1. mode
    webpack增加了一个mode配置，只有两种值development | production。对不同的环境他会启用不同的配置。
2. CommonsChunkPlugin
    CommonChunksPlugin已经从webpack4中移除。
    可使用optimization.splitChunks进行模块划分(提取公用代码)。
    但是需要注意一个问题，默认配置只会对异步请求的模块进行提拆分，如果要对entry进行拆分，需要设置optimization.splitChunks.chunk = 'all'。
3. webpack4使用MiniCssExtractPlugin取代ExtractTextWebpackPlugin。
4. 代码分割
    使用动态import，而不是用system.import或者require.ensure
5. vue-loader
    使用vue-loader插件为.vue文件中的各部分使用相对应的loader，比如css-loader等
6. UglifyJsPlugin
    现在再也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true。
    optimization.minimizer可以配置你自己的压缩程序

## babel和polyfill

* babel：ES6转码器，可以将ES6代码转为ES5代码。Babel默认制转换新的JavaScript菊花，而不转换新的API。
* polyfill：用于实现浏览器并不支持的原生API的代码




