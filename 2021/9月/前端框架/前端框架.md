# 前端框架

## 关于数据变化和渲染性能优化

数据变化的检测基本只有三种方式：watch、脏检查、不检查。

- vue 就是基于数据的 watch 的，组件级别通过 Object.defineProperty 监听对象属性的变化，重写数组的 api 监听数组元素的变化，之后进行 dom 的更新。
- angular 则是基于脏检查，在每个可能改变数据的逻辑之后都对比下数据是否变了，变了的话就去更新 dom。
- react 则是不检查，不检查难道每次都渲染全部的 dom 么？ 也不是，不检查是因为不直接渲染到 dom，而是中间加了一层虚拟 dom，每次都渲染成这个虚拟 dom，然后 diff 下渲染出的虚拟 dom 是否变了，变了的话就去更新对应的 dom。

这就是前端框架的数据驱动视图变化的三种思路

- vue 是组件级别的数据 watch，当组件内部监听数据变化的地方特别多的时候，一次更新可能计算量特别大，计算量大了就可能会导致丢帧，也就是渲染的卡顿。所以 vue 的优化方式就是把大组件拆成小组件，这样每个数据就不会有太多的 watcher 了。
- react 并不监听数据的变化，而是渲染出整个虚拟 dom，然后 diff。基于这种方案的优化方式就是对于不需要重新生成 vdom 的组件，通过 shouldComponentUpdate 来跳过渲染。

但是当应用的组件树特别大的时候，只是 shouldComponentUpdate 跳过部分组件渲染，依然可能计算量特别大。计算量大了同样可能导致渲染的卡顿，怎么办呢？

树的遍历有深度优先和广度优先两种方式，组件树的渲染就是深度优先的，一般是通过**递归**来做，但是如果能通过链表记录下路径，就可以变成循环。变成了循环，那么就可以按照时间片分段，让 vdom 的生成不再阻塞页面渲染，这就像操作系统对多个进程的分时调度一样。

这个通过把**组件树改成链表**，把 vdom 的生成从递归改循环的功能就是 **react fiber**。

fiber 节点相对于之前的组件节点来说，没有了 parent、children 这种属性，多了 child、sibling、return 属性。

通过 fiber 链表树，优化了渲染的性能。

## 关于逻辑复用

- vue 是options对象的方式，自然想到通过对象属性的mixin，vue2 组件内逻辑复用方案就是mixin
- react刚开始也支持mixin，后来废弃了。HOC、render props

HOC的逻辑复用方式最终导致了组件嵌套太深，而且class内部生命周期比较多，逻辑都放在一起导致组件比较大。

function组件的fiber节点加入了fiber.memorizedState属性来存储数据，然后再function组件里面通过api来使用这些数据，这些api被叫做hooks api。因为是使用 fiber 节点上的数据，就把 api 命名为了 useXxx

每个 hooks api 都要有自己存放数据的地方，怎么组织呢？有两种方案，一种是 map，一种是数组。

- 用 map 的话那么要 hooks api 要指定 key，按照 key 来存取 fiber 节点中的数据。
- 用数组的话顺序不能变，所以 hooks api 不能出现在 if 等逻辑块中，只能在顶层。

为了简化使用， hooks 最终使用了数组的方式。当然，实现起来用的是链表。

hooks api分类
- 数据类
  - useState： 在 fiber.memoriedState 的对应元素中存放数据
  - useMemo：在 fiber.memoriedState 的对应元素中存放数据，值是缓存的函数计算的结果，在 state 变化后重新计算值
  - useCallback：在 fiber.memoriedState 的对应元素中存放数据，值是函数，在 state 变化后重新执行函数，是 useMemo 在值为函数的场景下的简化 api，比如 useCallback(fn, [a,b]) 相当于 useMemo(() => fn, [a, b])
  - useReducer：在 fiber.memoriedState 的对应元素中存放数据，值为 reducer 返回的结果，可以通过 action 来触发值的变更
  - useRef：在 fiber.memoriedState 的对应元素中存放数据，值为 {current: 具体值} 的形式，因为对象不变，只是 current 属性变了，所以不会修改。
- 逻辑类
  - useEffect：异步执行函数，当依赖 state 变化之后会再次执行，当组件销毁的时候会调用返回的清理函数
  - useLayoutEffect： 在渲染完成后同步执行函数，可以拿到 dom
- ref转发

再回头看一下最开始要解决的 class 组件嵌套过深和组件太大的问题，通过 hooks 都能解决：

- 逻辑扩展不需要嵌套 hoc 了，多调用一个自定义的 hooks 就行
- 组件的逻辑也不用都写在 class 里了，完全可以抽离成不同的 hooks

react 通过 function 组件的 hooks api 解决了 class 组件的逻辑复用方案的问题。**（fiber 是解决性能问题的，而 hooks 是解决逻辑复用问题的）**
