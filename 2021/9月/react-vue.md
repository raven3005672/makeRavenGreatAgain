
## key的异同

**react**

react默认将循环的index作为key来用作第一次渲染。源码本质上是暴力比较法：由于单链表
fiber无法使用双指针算法，所以无法对算法使用双指针优化。

总体上经历两轮遍历，第一轮遍历：处理更新的节点，第二轮遍历：处理剩下的不属于更新的节点。

为了降低算法复杂度，React的diff会预设限制：

1. 只对同级元素进行diff。如果一个DOM节点在前后两次更新中跨域了层级，那么React不会尝试复用它。
2. 两个不同类型的元素会产生出不同的树。
3. 先判断key再判断type，两者相同则为同一节点。

**vue**

vue3在DOM-Diff过程中，根据newIndexToOldIndexMap新老节点索引列表找到最长稳定序列，通过最长增长子序列的算法比对，找出新旧节点中不需要移动的节点，原地复用，仅对需要移动或已经patch（新增删除节点等操作）节点进行操作，最大限度地提升替换效率。

## diff的宏观比较

在react中如果某个组件的状态发生改变，react会把此组件以及此组件的所有后代组件重新渲染，不过重新渲染并不代表会全部丢弃上一次的渲染结果，react还是会通过diff去比较两次的虚拟dom最后patch到真实的dom上。虽然如此，如果组件树过大，diff其实还是会有一部分的开销。react内部通过 fiber优化 diff算法，外部建议开发者使用 shouldComponentUpdate pureComponent 来规避问题。

vue2的响应式是Object.defineProperty实现的，并且重写getter``setter等一系列操作实现观察者模式，一旦数据发生变化，不会像react一样去比较整颗组件树，而是去更新数据状态变化了的组件实例。

## 生命周期

## 函数式编程

## 事件处理

react16将合成事件挂载到document上，17版本后为root根元素。

