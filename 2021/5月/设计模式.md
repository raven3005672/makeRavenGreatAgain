## 十大设计原则

- 单一职责原则：实现类要职责单一。
- 开放封闭原则：要对扩展开放，对修改关闭。
- 里氏替换原则：不要破坏继承体系。
- 接口隔离原则：设计接口的时候要精简单一。
- 依赖倒置原则：面向接口编程。
- 最少知识原则：降低耦合度。
- 组合/聚合复用原则：多用组合少用继承。
- 不要重复你自己：代码逻辑重复单语义不同应该保留。
- 尽量保持简单
- 不要过度设计你暂时用不到的逻辑
  
善战者无赫赫之功善医者无煌煌之名，大智若愚大巧若拙，真正的好代码并不是用了多少厉害的技术与奇技淫巧，而是看尽人世繁华后的返璞归真，寥寥几笔实现了功能的同时却没有任何个人风格的痕迹，符合代码规范、编程思想、设计模式的代码。

## 设计模式

- 5种创建型

抽象工厂、工厂、单例、建造者、原型

- 7种结构型

桥接、代理、装饰器、适配器、享元、组合、门面（外观）

- 11种行为型

观察者、模板、迭代、状态、命令、终结者、解释器、职责链、访问者、策略、备忘录

### 创建型设计模式

封装对象创建过程，将对象的创建和使用解耦。

#### 单例模式

处理资源访问冲突，用来创建全局唯一类。

#### 工厂模式

用来创建继承同一父类、实现同一接口的子类对象，由给定的类型参数创建具体的对象。

#### 抽象工厂模式

继承同一父类，实现同一接口的子类对象，由给定的多个类型参数创建具体的对象。

#### 建造者模式

创建时有很多必填参数需要验证；创建时参数求值有先后顺序、相互依赖；创建有很多步骤，全部成功才能创建对象。

#### 原型模式

- 原型模式是基于已有的对象克隆数据，而不是修改原型链！
- 创建对象的代价太大，而同类的不同实例对象属性值基本一致。通过原型克隆的方式节约资源。
- 不可变对象通过浅克隆实现。
- 可变对象通过深克隆实现，深克隆占用资源多。
- 同一对象不同时间版本，可以对比没变化的浅克隆，变化的深克隆，然后新版本替换旧版本。

### 结构型设计模式

总结了一些类或对象组合在一起的经典结构，这些经典结构可以解决特定应用场景的问题，将类或对象的结构和使用解耦

#### 桥接模式

- 将抽象和实现解耦，让它们可以独立变化。
- 一个类存在多个独立变化的维度，我们通过组合的方式，让多个维度可以独立进行扩展。
- 非常类似于组合优于继承原则。

#### 代理模式

- 给原类添加非功能性需求，为了将代码与原业务解耦。
- 业务系统的非功能性需求开发：监控、统计、鉴权、限流、日志、缓存。

#### 装饰器模式

- 装饰器类是对原始功能的增强。
- 装饰器类和原始类继承同样的父类，这样我们可以对原始类嵌套多个装饰器类。
- 主要解决继承关系过于复杂的问题，通过组合来替代继承。
- 可以通过对原始类嵌套使用多个装饰器。

#### 适配器模式

- 适配器模式用于补救设计上的缺陷，将不兼容的接口变得兼容。
- 封装有缺陷的接口设计。
- 统一多个类的接口设计。
- 替换依赖的外部系统。
- 兼容老版本接口。
- 适配不同格式的数据。

#### 享元模式

共享的单元。复用对象，节省内存，前提是享元对象是不可变对象(初始化之后不再改变)。

#### 组合模式

将一组对象组织成树形结构，以表示一种“部分-整体”的层次结构。组合模式让客户端可以统一单个对象和组合对象的处理逻辑(递归遍历)。

#### 门面（外观）模式

- 将多个后端接口请求合并为一个（冗余接口），提高响应速度，解决性能问题。
- 通过封装细粒度接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性。

### 行为型设计模式

总结了一些类或对象交互的经典方式，将该行为相关的类或对象解耦。

#### 观察者模式

- 将观察者与被观察者解耦。
- 发布订阅模式有发布订阅调度中心(中间商)，观察者模式没有！

#### 模板模式

- 在一个方法里定义一个算法(业务逻辑)骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。
- 复用 扩展。

#### 策略模式

- 定义一族算法族，将每个算法分别封装起来，让他们可以相互替换。
- 避免冗长的 if-else 或 switch 分支判断。

#### 职责链模式

- 多个处理器 ABC 依次处理同一个请求，形成一个链条，当某个处理器能处理这个请求，就不会继续传递给后续处理器了。
- 过滤器 拦截器 处理器。

#### 状态模式

将事物内部的每个状态分别封装成类, 内部状态改变会产生不同行为。

#### 迭代器模式

遍历集合对象

#### 访问者模式

允许一个或多个操作应用到一组对象上，解耦操作和对象本身。

#### 备忘录模式

在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。

#### 命令模式

命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等。将命令的发起者和执行者解耦。

#### 解释器模式

给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

#### 中介模式

中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（依赖关系）转换成一对多（星状关系）。原本一个对象要跟n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象间的交互关系，降低了代码复杂度，提高了代码的可读性和可维护性。
