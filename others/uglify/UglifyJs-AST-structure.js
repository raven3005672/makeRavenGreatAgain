// You can get a cruel description of the AST with uglifyjs --ast-help.
// Each definition starts with the node name(i.e. AST_Node), followed by a list of own properties in parens(if it has any), followed by a string description and followed by any subclasses(if there are any).
// Nodes inherit properties from the base classes;
// for examples since the start and end properties are defined in the base class AST_Node, then every node contains those properties.

// The parser will instantiate the most specific subclass; for example you will never find an object of type AST_Node in the AST; that's just the base class.
// You won't find an AST_Statement either, since every kind of statment has its own dedicated subclass.

// The AST Nodes
// The following hierarchy is generated by your browser using introspection from the UglifyJS objects.
// Click a node to get a brief description of it. See below for some information on AST_Token, alse take a look at the scope analyzer for more information about properties in red and SymbolDef.

AST_Node (start end) "Base class of all AST nodes" {
    AST_Statement "Base class of all statements" {
        AST_Debugger "Represents a debugger statement"
        AST_Directive (value scope) 'Represents a directive, like "use strict";'
        AST_SimpleStatement (body) "A statement consisting of an expression, i.e. a = 1 + 2"
        AST_Block (body) "A body of statements (usually bracketed)" {
            AST_BlockStatement "A block statement"
            AST_Scope (directives variables functions uses_with uses_eval parent_scope enclosed cname) "Base class for all statements introducing a lexical scope" {
                AST_Toplevel (globals) "The toplevel scope"
                AST_Lambda (name argnames uses_arguments) "Base class for functions" {
                    AST_Function "A function expression"
                    AST_Defun "A function definition"
                }
            }
            AST_Switch (expression) "A `switch` statement"
            AST_SwitchBranch "Base class for `switch` branches" {
                AST_Default "A `default` switch branch"
                AST_Case (expression) "A `case` switch branch"
            }
            AST_Try (bcatch bfinally) "A `try` statement"
            AST_Catch (argname) "A `catch` node; only makes sense as part of a `try` statement"
            AST_Finally "A `finally` node; only makes sense as part of a `try` statement"
        }
        AST_EmptyStatement "The empty statement (empty block or simply a semicolon)"
        AST_StatementWithBody (body) "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`" {
            AST_LabeledStatement (label) "Statement with a label"
            AST_DWLoop (condition) "Base class for do/while statements" {
                AST_Do "A `do` statement"
                AST_While "A `while` statement"
            }
            AST_For (init condition step) "A `for` statement"
            AST_ForIn (init name object) "A `for ... in` statement"
            AST_With (expression) "A `with` statement"
            AST_If (condition alternative) "A `if` statement"
        }
        AST_Jump "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)" {
            AST_Exit (value) "Base class for “exits” (`return` and `throw`)" {
                AST_Return "A `return` statement"
                AST_Throw "A `throw` statement"
            }
            AST_LoopControl (label) "Base class for loop control statements (`break` and `continue`)" {
                AST_Break "A `break` statement"
                AST_Continue "A `continue` statement"
            }
        }
        AST_Definitions (definitions) "Base class for `var` or `const` nodes (variable declarations/initializations)" {
            AST_Var "A `var` statement"
            AST_Const "A `const` statement"
        }
    }
    AST_VarDef (name value) "A variable declaration; only appears in a AST_Definitions node"
    AST_Call (expression args) "A function call expression" {
        AST_New "An object instantiation.  Derives from a function call since it has exactly the same properties"
    }
    AST_Seq (car cdr) "A sequence expression (two comma-separated expressions)"
    AST_PropAccess (expression property) 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`' {
        AST_Dot "A dotted property access expression"
        AST_Sub 'Index-style property access, i.e. `a["foo"]`'
    }
    AST_Unary (operator expression) "Base class for unary expressions" {
        AST_UnaryPrefix "Unary prefix expression, i.e. `typeof i` or `++i`"
        AST_UnaryPostfix "Unary postfix expression, i.e. `i++`"
    }
    AST_Binary (left operator right) "Binary expression, i.e. `a + b`" {
        AST_Assign "An assignment expression — `a = b + 5`"
    }
    AST_Conditional (condition consequent alternative) "Conditional expression using the ternary operator, i.e. `a ? b : c`"
    AST_Array (elements) "An array literal"
    AST_Object (properties) "An object literal"
    AST_ObjectProperty (key value) "Base class for literal object properties" {
        AST_ObjectKeyVal "A key: value object property"
        AST_ObjectSetter "An object setter property"
        AST_ObjectGetter "An object getter property"
    }
    AST_Symbol (scope name thedef) "Base class for all symbols" {
        AST_SymbolDeclaration (init) "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)" {
            AST_SymbolVar "Symbol defining a variable" {
                AST_SymbolFunarg "Symbol naming a function argument"
            }
            AST_SymbolConst "A constant declaration"
            AST_SymbolDefun "Symbol defining a function"
            AST_SymbolLambda "Symbol naming a function expression"
            AST_SymbolCatch "Symbol naming the exception in catch"
        }
        AST_Label (references) "Symbol naming a label (declaration)"
        AST_SymbolRef "Reference to some symbol (not definition/declaration)" {
            AST_LabelRef "Reference to a label symbol"
        }
        AST_This "The `this` symbol"
    }
    AST_Constant "Base class for all constants" {
        AST_String (value) "A string literal"
        AST_Number (value) "A number literal"
        AST_RegExp (value) "A regexp literal"
        AST_Atom "Base class for atoms" {
            AST_Null "The `null` atom"
            AST_NaN "The impossible value"
            AST_Undefined "The `undefined` value"
            AST_Infinity "The `Infinity` value"
            AST_Boolean "Base class for booleans" {
                AST_False "The `false` atom"
                AST_True "The `true` atom"
            }
        }
    }
}

// The tokenizer
// For a higher-level operation, the parser works concomitantly with a tokenizer.
// The tokenizer is initialized to the stream of the source code text and reads one token at a time, producing an AST_Token object which has the following properties:
// type —— the type of this token; can be 'num', 'string', 'regexp', 'operator', 'punc', 'atom', 'name', 'keyword', 'comment1' or 'comment2'.
//          'comment1' and 'comment2' are for single-line, respectively multi-line comments.
// file —— the name of the file where this token originated from. Useful when compressing multiple files at once to generate the proper source map.
// value —— the 'value' of the token; that's additional information and depends on the token type:
//          'num', 'string' and 'regexp' tokens you get their literal value;
//          for 'operator' you get the operator;
//          for 'punc' it's the punctuation sign(parens, comma, semicolon etc);
//          for 'atom', 'name' and 'keyword' it's the name of the identifier, and for comments it's the body of the comment(excluding the initial '//' and '/*')
// line and col —— the location of this token in the original code. The line is 1-based index, and the column is the 0-based index.
// pos and endpos —— the zero-based start and end positions of this token in the original text.
// nlb —— short for 'newline before', it's a boolean that tells us whether there was a newline before this node in the original source.
//          It helps for automatic semicolon insertion. For multi-line comments in particular this will be set to true if there either war a newline before this comment, or if this comment contains a newline.
// comments_before —— this doesn't apply for comment tokens, but for all other token types it will be an array of comment tokens that were found before.

// The start and end properties of AST nodes are AST_Token objects and tell you where that node begins and ends.
// The AST_Toplevel is the single node that might start in one file and end in another(when parsing multiple files); the parser will property update its and property.






