# 网络

## 5层模型

- 应用层
  - http、ftp、dns
- 传输层
  - tcp、udp
- 网络层
  - ip
- 数据链路层
  - 以太网、p2p
- 物理层
  - 蓝牙、wifi、光纤

## TCP连接的过程（三次握手，四次挥手）

client（等待连接） ==syn==> server
client <==syn+ack== server（同意连接请求）
client（建立连接） ==ack==> server（建立连接）

client（不能再发数据，可以读取数据） ==fin==> server
client <==ack== server（不能读取数据，可以再发数据）
client <==fin== server (不能读取数据，不能发送数据)
client ==ack==> server

## HTTPS

client => server 告知算法和密钥长度等信息
server 响应公钥和服务器证书（CA机构签名）
client 验证证书合法，然后生成一个会话密钥，并用服务器公钥加密，加密结果发送给server
server 私钥解密保存，会话密钥加密消息响应 client
client 用会话密钥解密消息，连接就绪

对称加密：私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。算法公开、加密和解密速度快，适合对大数据量进行加密。
非对称加密：公钥加密，安全性更好，公钥和私钥成对出现。一个进行加密，另一个进行解密。

非对称加密进行身份认证，对称加密进行数据传输

## SSL、TLS

TLS是SSL的升级版，介于传输层与应用层之间

## HTTPS中间人攻击

劫持 => 伪造证书
剥离 => 发送给客户端HTTP明文连接

## HTTP 1.0-1.1-2.0

1.0 每次请求响应后销毁、前一个完成才发送后一个
无法复用连接、队头阻塞
1.1 长链接（keep-alive）、管道化（非阻塞，响应顺序仍然是顺序）、缓存处理（cache-control）、断点传输
2.0 二进制分帧、多路复用（非阻塞，也不用遵守响应顺序）、头部压缩、服务器推送

- 1.1如何复用tcp连接
  - connection:keep-alive 减少三次握手四次挥手，不是真正的并行传输
  - 一般把静态资源分发到不同域名下的资源服务器，实现真正的并行传输
- 2.0如何多路复用
  - 帧代表最小数据单位，同时表示出该帧属于哪个流。一个TCP连接中可以存在多条流，也就是发送多个请求。

http3使用UDP协议，为了保证传输的可靠性，使用了QUIC协议。以解决HTTP/2中存在的队头阻塞（Head-of-line Blocking）问题

## 强缓存、协商缓存

Expires（1.0） - 失效时间
Cache-control（1.1） - 有效期（优先级高于Expires）
Last-modify

## HTTP状态码

301 —— 永久重定向，适合域名变更（下次浏览器会请求新地址）
302 —— 临时重定向，适合临时转移（下次浏览器仍然会请求老地址）
304 —— 资源未修改，建议使用缓存（服务器不会附带任何的响应）
403 —— 不允许访问，权限不足

## token加密

以jwt为例，一般分三部分：header、payload、signature。header标识签名算法和令牌类型、payload标识主题信息、signature使用特定的算法对前面两部分进行加密。

## SSO单点登录

一般需要一个独立的认证中心（passport），子系统的登录均通过passport，当一个系统成功登录以后，passport会颁发一个令牌给各个子系统，子系统可以拿着令牌获取各自的受保护资源，减少频繁认证。

## 文件上传

client将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时附带序号。
server接收到每片数据时，将其保存成一个临时文件，并记录每个文件的hash和序号。
上传中止再恢复时，可以向server索要已上传的分片序号，client仅需上传剩余分片。

## HTTP劫持、DNS劫持、XSS、CSRF

http劫持：攻击者在客户端和服务器之间同时建立了连接通道（运营商广告注入）
DNS劫持：攻击者劫持了DNS服务器，导致客户端请求的域名被解析到错误的IP地址
XSS：跨域脚本攻击，表单提交时，在表单内容中加入一些恶意脚本
CSRF：跨站请求伪造（cookie），挟制用户在当前已登录的web应用上执行非本意的操作和攻击方法

## WebSocket（即时通讯）

HTML5带来的新协议，是一个持久连接的协议，利用http完成握手，然后通过TCP连接通道发送消息，可以实现服务器主动推送消息。

短轮询：客户端每隔一段时间就像服务端发送消息；
长轮询：发起一次请求询问服务器，服务器可以将请求挂起，等到有新消息的时候再进行响应。响应后，客户端再发起一个新的请求。

## 跨域

JSONP、cors

## 浏览器输入地址按下回车后发生了什么

- 浏览器自动补全协议、端口
- 浏览器自动完成url编码
- 浏览器查找本地缓存、命中缓存则直接使用缓存
- DNS解析找到服务器的ip地址
- 浏览器向服务器发出建立TCP连接的申请，完成三次握手。
- HTTPS协议还会进行SSL握手，会确定是否使用HTTP2
- 浏览器决定要附带哪些cookie到请求头
- 浏览器自动设置好请求头、协议版本、cookie，发GET请求
- 服务器处理请求、响应一个HTTP报文给浏览器
- 浏览器根据使用的协议版本，以及connection字段的约定，决定是否保留TCP连接
- 浏览器根据响应状态码决定如何处理这一次响应
- 浏览器根据响应头中的Content-Type识别响应类型，如果是text/html则对响应体的内容进行HTML解析
- 浏览器根据响应头的其他内容完成缓存、cookie设置
- 浏览器开始从上到下解析HTML，遇到外部资源链接，则进一步请求资源
- 生成DOM树，CSSOM树，二者合并为渲染树，然后对渲染树的每个节点计算位置和大小（reflow重排），最后把每个节点利用GPU绘制到屏幕（repaint重绘）
- 在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件

## cookie、sessionStorage、localStorage

- cookie兼容性好，默认行为，大小限制，同一个域下cookie总量4m
- sessionStorage会话级别的数据，无大小限制，只与domain关联
- localStage持久保存，无大小限制，只与domain关联

## defer、async

- defer，脚本在执行时不会影响页面的构造，会被延迟到整个页面都解析完毕后再执行。DOMContentLoaded事件触发完成之前完成。
- async，告诉浏览器立即下载文件，下载完成后立即执行，与文档流并行异步。

## 取消请求
 
xx = new AbortController();
xx?.abort();

## chrome浏览器一个tab页面，至少会出现几个进程

- 浏览器主进程
- GPU进程
- 网络进程
- 渲染进程（多页面属于同一个站点会共用一个渲染进程，多开崩溃问题）
- 插件进程
- iframe进程