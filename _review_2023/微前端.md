# 微前端

## qiankun

qiankun基于single-spa进行了二次开发

- 主应用：只需要输入子应用的html入口
- 子应用：与single-spa基本一致，导出了三个生命周期函数。
- js隔离
  - Proxy沙箱，它将window上的所有属性遍历拷贝生成一个新的fakeWindow对象，紧接着使用proxy代理这个fakeWindow，用户对window操作全部被拦截下来，只作用于在这个fakeWindow之上
- css隔离
  - ShadowDOM样式沙箱会被开启。在这种模式下 qiankun 会为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响。
  - Scoped CSS，qiankun会遍历子应用中所有的CSS选择器，通过对选择器前缀添加一个固定的带有该子应用标识的属性选择器的方式来限制其生效范围，从而避免子应用间、主应用与子应用的样式相互污染。
    - micro-app[name=xxx] .test { height: 100px; }
  - 但如果用户在运行时引入了新的外联样式或者自行创建了新的内联标签，那么qiankun并不会做出反应
- qiankun在框架内部预先设计实现了完善的发布订阅模式

shadowDOM、webComponent、CustomElement

改标签、资源地址补完

沙箱、window代理、document隔离

## 工作原理

- 应用加载：动态创建script标签加载子应用的入口文件
- 生命周期管理：子应用要暴露出bootstrap、mount、unmount三个生命周函数。
  - 加载时bootstrap、应用启动时mount、应用卸载时unmount
- 沙箱隔离：Proxy沙箱
- 样式隔离：动态添加和移除样式标签
- 通信机制

## 静态资源加载问题、子应用动态插入标签、

- 使用公共路径前缀
- 劫持标签插入函数
  - 支持重写getTemplate函数，将入口文件中的静态资源路径替换掉
  - 劫持appendChild、innerHTML、insertBefore等方法，将相对路径替换为绝对路径
- webpack
- iframe

## start函数的作用和参数

用来启动微前端应用的。在注册完所有的子应用之后，需要调用start函数来启动微前端应用。

- prefetch：预加载模式。在主应用start之后即可开始预加载所有子应用的静态资源。
- sandbox：沙箱模式。为每个子应用创建一个新的沙箱环境。strictStyleIsolation会启用严格的样式隔离模式。
- singular：单例模式。一次只能有一个子应用处于激活状态
- fetch：自定义用于加载子应用的静态资源的fetch方法

## js沙箱不能解决的js污染问题

onclick或者addEventListener给body添加点击事件，js沙箱并不能消除它的影响。

需要子应用在unmount生命周期中移除这个事件。

## keep-alive

略，display：none。

设计理念相悖，子应用卸载的时候会把环境还原到加载之前的状态，防止对全局环境造成污染。

## qiankun和iframe对比

iframe隔离属性更强

## 多个子项目调试问题

npm-run-all 并行/串行多个npm脚本

## qiankun的css隔离

ShadowDOM实现的，创建了一个封闭的DOM结构，这个DOM结构对外部是隔离的，包括其CSS样式。
qiankun在挂载子应用时，会将子应用的HTML元素挂载到ShadowDOM上。

## 父子项目间通信

Actions通信：qiankun官方提供的通信方式，主要通过setGlobalState设置globalState，并通过onGlobalStateChange和offGlobalStateChange来注册和取消观察者函数，从而实现通信。

```js
window.globalEvent = {
  events: {},
  emit(event, data) {
    if (!this.events[event]) {
      return;
    }
    this.events[event].forEach(callback => callback(data));
  },
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
}
```

## 子项目路由hash、history

- 主history
  - 子用history或hash都可以，主项目router或原生history跳转
- 主hash
  - 子hash，使用path区分子项目，原生history跳转
  - 子hash，使用hash区分子项目，自定义activeRule，需要修改子项目
  - 子history，使用path/hash区分子项目，原生history跳转

## 组件在不同项目间共享

- 父子项目之间
  - 组件挂载到全局
- 子项目之间
  - 通过主项目提供的全局变量，异步加载（弱依赖）
  - loadMicroApp手动加载子项目，传递函数给子项目，在需要使用共享组件的地方，手动加载提供组件的子项目

## 应用之间复用依赖

- webpack配置externals，将公共依赖指定为外部依赖
- CDN文件复用
- 自定义属性ignore，独立子项目运行会加载，微前端模式会复用
- 解决全局变量冲突
  - 注册子项目，在beforeLoad钩子函数中处理全局变量，将子项目的全局变量进行替换
  - 主项目将依赖通过props传递给子项目
  - 修改依赖名称

## webpack5联邦模块

ModuleFederationPlugin插件
- exposes导出
- remotes引入

动态加载

## 资源加载机制 import-html-entry

- 加载HTML入口文件：link标签加载子应用的HTML入口文件
- 解析HTML入口文件：解析文件内容，提取js和css的url
- 动态加载资源：动态创建script和link标签，按照正确的顺序加载子应用的资源
- 创建沙箱环境：加载js资源时候，创建沙箱环境，隔离父子应用
- 返回子应用的入口模块：返回一个可以加载子应用的js模块，这个模块通常是一个包含子应用初始化代码的函数，可以在主应用中调用以加载和启动子应用

qiankun实现了html entry，而single-spa只能是js entry



