// 在某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。
// 对于下面这个递归就会无限制的执行下去，知道超出调用堆栈的实际大小，这个是浏览器定义的。
function foo() {
    foo();
}
foo();

// 内存空间详解
// 栈数据结构：后进先出LIFO
// 堆数据结构：树状结构，key-value
// 队列结构：先进先出，这是事件循环EventLoop的基础结构

// 变量的存放
// 1.基本类型，保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。
// 基本类型一共有6中：Undefined、Null、Boolean、Number、String和Symbol
// 2.引用类型，保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小是固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。
// 当查询引用类型的变量时，先从栈中读取内存地址，然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。
// 如图1-3-1
// 在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构切可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去栈查找再去堆查找。


// 内存空间管理
// javascript的内存生命周期是
// 1.分配你所需要的内存
// 2.使用分配到的内存（读、写）
// 3.不需要时剑气释放、归还

// javascript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到那些对象是不再继续使用的，使用a=null其实仅仅只是做了一个释放引用的操作，让a原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

// 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。

var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x 	// undefined
b.x     // {n:2}


