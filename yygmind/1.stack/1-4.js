// JS内存空间
// 分为栈stack、堆heap、池【一般也会归类到栈中】。其中栈存放变量，堆存放复杂对象，池存放常量，所以页脚常量池。

// 基本类型 -> 栈内存（不包含闭包中的变量）
// 引用类型 -> 堆内存
// 闭包中的变量并不保存在栈内存中，而是保存在堆内存中，这就解释了函数之后为什么闭包还能引用到函数内的变量。
function A() {
    let a = 1;
    function B() {
        console.log(B);
    }
    return B;
}
// 闭包的简单定义是：函数A返回了一个函数B，并且函数B中使用了函数A的变量，函数B就被称为闭包。

// 函数A弹出调用栈后，函数A中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。
// 关于闭包的详细介绍见第二期


// 内存回收和内存泄漏
// 内存回收
// javascript有自动垃圾回收机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。
// 局部变量和全局变量的销毁
// 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
// 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。

// Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的。
// 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
// 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。
// V8引擎对堆内存中的JS对象进行分代管理
// 新生代：存货周期较短的JS对象，如临时变量、字符串等。
// 老生带：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。


// 垃圾回收算法
// 对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。
// 引用计数（现代浏览器不再使用）
// 标记清除（常用）


// 引用计数
// 引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。

// 创建一个对象person，他有两个指向属性age和name的引用
var person = {
    age: 12,
    name: 'aaaa'
};
person.name = null; // 虽然name设置为null, 但因为person对象还有指向name的引用，因此name不会回收
var p = person;
person = 1;         // 原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收
p = null;           // 原person对象已经没有引用，很快会被回收

// 引用计数有一个致命的问题，那就是循环引用
// 如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄漏。
function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1;
    return "cycle reference!"
}
cycle();
// cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。


// 标记清除（常用）
// 标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中间就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部触发无法触及到的对象被标记为不再使用，稍后进行回收。
// 无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。

// 现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄漏一般都与DOM元素绑定有关：
email.message = document.createElement('div');
displayList.appendChild(email.message);
// 稍后从displayList中清除DOM元素
displayList.removeAllChildren();
// 上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。


// 内存泄漏
// 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）

// 内存泄漏识别方法
// 1.浏览器方法
// 打开开发者工具，选择Memory。
// 在右侧的Select profiling type字段里面勾选timeline。
// 点击左上角的录制按钮。
// 在页面上进行各种操作，模拟用户的使用情况。
// 一段时间后，点击左上角的stop按钮，面板上就会显示这段时间的内存占用情况。

// 2.命令行方法
// 使用Node提供的process.memoryUsage方法。
console.log(process.memoryUsage());
// // 输出
// {
//     rss: 27709440,          // resident set size，所有内存占用，包括指令区和堆栈
//     heapTotal: 5685248,     // "堆"占用的内存，包括用到的和没用到的
//     heapUsed: 3449392,      // 用到的堆的部分
//     external: 8772          // V8引擎内部的C++对象占用的内存
// }
// 判断内存泄漏，以heapUsed字段为准


WeakMap
// ES6新出的两种数据结构：WeakSet和WeakMap，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。
const wm = new WeakMap();
const element = document.getElementById('example');
wm.set(element, 'some information');
wm.get(element);        // some information
// 先新建一个WeakMap实例，然后将一个DOM节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在WeakMap里面。这时，WeakMap里面对element的引用就是弱引用。


// 从内存来看null和undefined本质的区别是什么？
// 给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性赋值null，或者局部变量赋值为null，相当于给这个属性分配了一块空的内存，然后值为null，JS会回收全局变量为null的对象。
// 给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在，如果给对象的属性赋值为undefined，说明这个值为空值。

// ES6语法中的const声明一个只读的常量，那为什么下面可以修改const的值？
const foo = {};
foo = {};       // err
foo.prop = 123;
// const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
// 但对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。

